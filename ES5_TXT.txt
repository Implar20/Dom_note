第一章 JavaScript简介
	1、JavaScript实现
		- 核心（ECMAScript）
		- 文档对象模型（DOM）
		- 浏览器对象模型（BOM）
		
	2、ECMAScript 组成
		- 语法
		- 类型
		- 语句
		- 关键字
		- 保留字
		- 操作符
		- 对象
		
	3、Js解释器（Web browser）是单线程的，即以此只能执行一件事件
	
	4、ECMA-262（初级阶段，即标准） = ECMAScript
	
	5、ECMA-262定义的只是这门语言的基础，而再次基础之上可以构建更完善的脚本语言
	
	6、DOM实际上是ECMAScirpt在Web浏览器上的扩展
	
	7、JS的宿主环境
		- Web浏览器
		- Node
		- Adobe Flash
		
第二章 在HTML中使用JavaScript
	1、async：表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他
	          资源或等待加载其他脚本
			  - 标记为async的脚本并不保证按照它们的先后顺序执行
			  - 如果要加载多个脚本，确保两者之间互不以来非常重要
			  - 只对外部脚本有用
			  - 异步脚本一定会在页面的Load事件前执行，但可能会在DOMContentLoaded之间触发之前或之后执行
			  
	2、defer：表示脚本可以延迟到文档完全被解析和显示之后再执行	=> 即立即下载，但延迟执行
			  - 只对外部脚本有用
			  - IE7及更早版本对嵌入脚本也支持该属性
			  - 在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在DOMContentLoaded事件触发前执行，
				因此最好只包含一个延迟脚本
	
	3、DOMContentLoaded：当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，
						 而无需等待样式表，图像和自框架的完成加载
						 
						 当文档中没有脚本时，浏览器解析完文档便能触发DOMContentLoaded事件，如
						 果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等待CSSOM构建完成
						 之后才执行，在任何情况下，DOMContentLoaded
						 - CSSOM = CSS模型对象
						 - jQuery：
							- $(document).ready(function(){}) => DOMContentLoaded
							- $(document).load(function(){}) => Load
	
	4、外部脚本的优点
		- 可维护性
		- 可缓存
		- 适应未来
		
	5、<noscript>元素
		当浏览器不支持JavaScript时，可以让页面平稳退化，这个元素里面可以包含任何HTML元素 ———— 除了script之外，
		包含在noscript的内容只有在下列情况下才会显示出来：
			- 浏览器不支持脚本
			- 浏览器支持脚本，但脚本被禁用
			
第三章 基本概念
	1、语法
		- ECMAScript中的一切都区分大小写
		- 标识符， 即变量、函数、属性的名字，或者函数的参数，标识符的命名规则：
			- 第一个字符必须是一个字母、下划线(_)或一个美元符号($)
			- 其他字符可以是字母、下划线、美元符号和数字
			- 驼峰大小写格式
		- 注释
			- // 单行注释
			- /* 多行注释 */
		- 严格模式 => "use strict"
			- 脚本严格
			- 函数严格
		- 语句
			- ECMAScript中的语句以分号结尾，分号可以省略，但任何时候都建议不要省略
			
	2、关键字和保留字
		- 关键字和保留字都不要作为标识符或属性名，否则会抛出错误
		
	3、变量
		- ECMAScript中的变量是松散类型的，松散类型就是可以用来保存任何类型的数据
		- 定义变量时，以var开头，后跟一个变量名(标识符)
			var message 
		  在没有为其赋值的情况下，message里面保存一个特殊的值 ———— undefined
		- 使用var定义的变量将会是该变量的作用域中的局部变量，也就是说在函数中使用var定义的变量会在函数退出后就被销毁
		- 省略var，可以创建一个全局变量，可以在函数外部访问，但不建议这样做
	
	4、数据类型
		- ECMAScript中有物种简单数据类型（基本数据类型）：
			- Undefined
			- Null
			- Boolean
			- Number
			- String
		- 一种复杂数据类型：
			- Object 本质是由一组无序的名值对组成的
		- ECMAScript不支持任何创建自定义类型的机制，所有值最终都将是上述的六种数据类型之一，由于ECMAScript数据类型具有动态性，所以没有在定义其他数据类型的必要
		- typeof操作符
			- 检测给定变量的数据类型
			- 操作数可以是变量，也可以是数值字面量
		- undefined类型
			- 在使用var声明变量但未对其加以初始化的时候，这个变量的值就是undefined
			- 包含undefined值的变量和尚未定义的变量是不一样的，后者会直接报错
			- 使用typeof对未初始化的变量和未定义的变量进行检测都将返回undefined
			- 无论何时都没有必要把一个变量的值显式的设置成undefined
		- null类型
			- null值表示一个空对象指针
			- 使用typeof检测null返回object
			- 可以将准备在未来用于保存对象的变量初始化为null
			- undefined值是派生自null值的，所以undefined和null的相等（不是全等）测试返回true，不过相等操作符出于比较的目的会转换成其他操作数进行比较
		- boolean类型
			- 在ECMAScript中使用的最多的一种类型，该类型只有两个字面量：true 和 false ，他们两个是区分大小写的
			- ECMAScript中所有值都与这两个boolean值有等价关系，如果需要进行转换，可以使用Boolean()转型函数
			- 各种数据类型及其对应的转换规则：
				Boolean				true							false
				String				任何非空字符串					""(空字符串)
				Number				任何非零数字值(包括无穷大)		0和NaN
				Object				任何对象						null
				Undefined			n/a								undefined
			- 在流控制语句if中可以直接使用上述转换规则 if(a) {alert(123)} => a自动转换成Boolean类型进行判断，即a是否存在
		- number类型
			- IEE754格式来表示整数和浮点数（小数）
			- 进制
				- 十进制	10
				- 八进制	070（第一位必须是0）
				- 十六进制	0xA（前两位必须是0x，后跟任何十六进制数字（0~9及A~F，可大写可小写））
			- 在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制
			- 浮点数值
				- 所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字（小数点前面可以没有数字，但不推荐）
				- 保存浮点数值需要的内存空间是保存整数值的两倍，所以如果小数点后面没有跟任何数字，或者本身表示的就是一个整数，那么该值也会被转换为整数
				- 对于极大和极小的数值可以用e表示法（科学记数法），格式：前面是一个数值（可以是整数或浮点数），中间是一个大写或小写的e，后面是10的幂中的指数，该幂值与前面的数相乘
				- 浮点数计算中 0.1 + 0.2 不等于 0.3
			- 数值范围
				- 由于内存的限制，ECMAScript不能保存世界上所有的数值
					- 最大值保存在Number.MAX_VALUE中 这个值是1.7976931348623157e+308，超出的为Infinity
					- 最小值保存在Number.MIN_VALUE中 这个值是5e-324 超出的为-Infinity
				- ± Infinity无法进行数值计算
				- isFinite()方法可以判断一个数值是不是有穷的，这个方法在参数位于最小值和最大值之间返回true
				- Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正Infinity的值
			- NaN
				- NaN，即非数值（Not a Number）是一个特殊的数值，用来表示一个本来要返回数值的操作数未返回数值的情况
				- 任何涉及NaN的操作都会返回NaN
				- NaN与任何值都不相等，包括NaN本身
				- isNaN()方法，接受一个参数，该参数可以是任何类型的值，这个方法会帮我们判断这个参数是否是“不是数值”
				- isNaN()方法在基于对象调用时，会调用对象的valueof()方法，如果不能转换为数值，再调用toString()方法，再返回测试值
			- 数制转换
				- 三个方法可以把非数值转换为数值：
					- Number()
						- 可以用于任何数据类型
						- 转换规则：
							- 如果是Boolean值，true和false将分别被转换为1和0
							- 如果是数字值，只是简单的传入和返回
							- 如果是null值，返回0
							- 如果是undefined，返回NaN
							- 如果是字符串
								- 如果字符串中只包含数字（包括前面带正号和负号的情况），则将其转换为十进制数值，即“1”会变成1，“123”会变成123，而“011”会变成11
								- 如果字符串中包含有效的浮点格式，如“1.1”，则将其转换为对应的浮点数值（同样，也会忽略前导零）
								- 如果字符串中包含有效的十六进制格式，例如“0xf”，则将其转换为相同大小的十进制整数值
								- 如果字符串是空的（不包含任何字符），则将其转换为0
								- 如果字符串中包含除上述格式之外的字符，则将其转换为NaN
							- 如果是对象，则调用对象的ValueOf()方法，然后依照前面的规则转换返回值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面
							  的规则转换返回的字符串值
						- 一元加操作符的操作与Number()函数相同
					- parseInt()
						- 只能用于字符串转换为数值的操作
						- 他会忽略字符串前面的空格，直到找到第一个非空格字符
						- 如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN
						- 对于空字符串也会返回NaN
						- 如果第一个字符是数字字符，那么parseInt()会继续解析第二个字符，知道解析完所有后续字符或者遇到了一个非数字字符
						- 可以解析各种整数格式
						- parseInt()可以接受第二个参数：转换时使用的基数（即多少进制）
						- 缺点：
							- 无法解析浮点数
					- parseFloat()
						- 只能用于字符串转换为数值的操作
						- 规则与parseInt()方法类似
						- 可以解析浮点数，即从第一个字符开始解析每个字符，一直解析到字符末尾，或者解析到遇见一个无效的浮点数字字符为止，也就是说字符串中的第一个小数点是有效的，第二个则无效
						- parseFloat()方法只能解析十进制
						- 如果字符串包含的是一个可解析为整数的数，parseFloat()会返回整数
		- String类型
			- 用于表示由零或多个16位Unicode字符组成的字符序列，即字符串
			- 用双引号表示的字符串和用单引号表示的字符串完全相同
			- ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，他们的之久不能改变了，要改变某个变量保存的字符串，首先要销毁原来的字符串再用另一个包含新值的字符串填充该变量
			- 诸如 \n \t 这种字符字面量可以出现在字符串中的任意位置，而且也被当作一个字符解析
			- 转换为字符串
				- 使用toString()方法，这个方法唯一要做的就是返回相应值的字符串表现，除了undefined和null之外的所有类型都有toString()方法
					- 再调用数值的toString()方法时，可以传递一个参数：输出数值的基数
				- 在不知道要转换的值是不是null和undefined的时候，可以使用String()方法，这个函数能将任何类型的值转换为字符串
					- 规则：
						- 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果
						- 如果值时null，则返回“null”
						- 如果值时undefined，则返回“undefined”
		- Object类型
			- ECMAScript中的对象其实就是一组数据和功能的集合
			- 对象可以通过new操作符后跟要创建的对象类型的名称来创建
			- 创建object类型的实例并未其添加属性和（或）方法，就可以创建自定义对象
			- Object类型是所有他的实例的基础，object类型所具有的任何属性和方法也同样存在于更具体的对象中
			- Object的每个实例都有下列的属性和方法：
				- constructor：保存着用于创建当前对象的函数。
				- hasOwnproperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名必须以字符串形式指定
				- isPrototypeOf(object)：用于检查传入的对象是否时当前对象的原型
				- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定
				- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应
				- toString()：返回对象的字符串表示
				- ValueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同
				由于在ECMAScript中Object时所有对象的基础，因此所有对象都具有这些基本的属性和方法（BOM和DOM中的对象除外，因为他们是由宿主实现提供和定义的）
		
	5、操作符
		- 算术操作符（加号和减号）、位操作符、关系操作符和相等操作符。ECMAScript中的操作符可以适用于很多值，如字符串、数字值、布尔值，甚至对象
		- 在应用与对象时，相应的操作符通常都会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值
		- 一元操作符
			- 只能操作一个值的操作符叫做一元操作符
			- 递增和递减操作符
				- ++ / -- 执行前置递增/递减操作时，返回自增以后的值 var a = 1; var b = ++ a; //a = 2, b = 2
				- ++ / -- 执行后置递增/递减操作时，返回自增以前的值 var a = 1; var b = a ++; //a = 2, b = 10
				- 规则：
					- 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，在执行加减1的操作。字符串变量变成数值变量
					- 在应用与一个不包含有效数字字符的字符串时，将变量的值设置为NaN。字符串变量变成数值变量
					- 在应用与布尔值false时，先将其转换为0在执行加减1的操作。布尔值变量变成数值变量
					- 在应用与浮点数值时，执行加减1的操作
					- 在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值，然后对该值应用前述规则。如果结果是NaN，则再调用toString()方法后在应用前述规则，对象变量变成数值变量
		- 一元加和减操作符
			- 对于数值来说不会产生任何影响
			- 对于非数值来说，该操作符就会像Number()转型函数一样对这个值执行转换。
				- 布尔值会转换成1和0，
				- 字符串会被按照一组特殊的规则进行解析
				- 对象则是先调用valueOf()和（或）toString()方法，在转换的到的值
			- 一元减操作符与一元加类似，只不过最后得到的结果是负数
		- 布尔操作符
			- 逻辑非 (!)
				- 无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反
				- 规则：
					- 如果操作数是一个对象，返回false
					- 如果操作数是一个空字符串，返回true
					- 如果操作舒适以恶搞非空字符串，返回false
					- 如果操作数是数值0，返回true
					- 如果操作数是任意非0数值（包括Infinity），返回false
					- 如果操作数是null，返回true
					- 如果操作数是NaN，返回true
					- 如果操作数是undefined，返回true
				- 使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为
			- 逻辑与 (&&)
				- 逻辑与的真值表：
					第一个操作数		第二个操作数		结果
					true				true				true
					true				false				false
					false				true				false
					false				false				false
				- 规则：
					- 如果第一个操作数是对象，则返回第二个操作数
					- 如果第二个操作时是对象，则只有再第一个操作数的求值结果为true时才会返回该对象
					- 如果两个操作数都是对象，则返回第二个操作数
					- 如果第一个操作数时null，则返回null
					- 如果第一个操作数是NaN，则返回NaN
					- 如果第一个操作数是undefined，则返回undefined
					即：
					- 如果两个值都为true，则返回后面的
					- 如果两个值都为false，则返回前面的
					- 如果一个为false，一个为true，则始终返回false
				- 逻辑与操作符是一个短路操作符，即如果第一个操作数是false，那么不管第二个数是什么，结果都不可能是true了
			- 逻辑或 (||)
				- 逻辑或的真值表：
					第一个操作数		第二个操作数		结果
					true				true				true
					true				false				true
					false				true				true
					false				false				false
				- 规则：
					- 如果第一个操作数是对象，则返回第一个操作数
					- 如果第一个操作数的求值结果为false，则返回第二个操作数
					- 如果两个操作数都是对象，则返回第一个操作数
					- 如果两个操作数丢失null，则返回null
					- 如果两个操作时都是NaN，则返回NaN
					- 如果两个操作数都是undefined，则返回undefined
					即：
					- 如果两个值都为true，则返回前面的
					- 如果两个值都为false，则返回后面的
					- 如果一个为false，一个为true，则始终返回true
				- 逻辑或也是一个短路操作符，即如果第一个操作数是true，那么就不会对第二个操作数进行求值了
				- 我们可以利用逻辑或的这一行为来避免为变量赋值null或undefined： var a = b || c // 如果b为null或undefined，则将c赋值给a，否则，将b赋值给a
		- 乘性操作符
			- ECMAScript定义了三个乘性操作符：乘法(*)、除法(/)和求模(%)
			- 如果参与乘性计算的某个操作数不是数值，后台会先对其进行Number()转型函数将其转换为数值。
			- 求模：
				- 如果被除数是0，则结果是0
				- 如果被除数小于除数，则返回被除数
				- 如果除数为0，则返回NaN
		- 加性操作符
			- 两个加性操作符：加法(+)和减法(-)
			- 同样会对非数值操作数进行数值转型
			- 对于操作数为对象、数值或布尔值，则调用他们的toString()方法取得相应的字符串，然后在进行转型，对于null和undefined，则调用String()
		- 关系操作符
			- 小于(<)、大于(>)、小于等于(<=)和大于等于(>=)
			- 当操作数为数值是，规则与数学规则相同
			- 当操作数为非数值时，规则如下：
				- 如果两个操作数都是数值，则执行数值比较
				- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值
				- 如果一个操作数是数值，则将另一个操作时转换为一个数值，然后执行数值比较
				- 如果一个操作数是对象，则调用这个对象的valueof()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueof()方法，则使用toString()方法
				  并用得到的结果进行比较
				- 如果一个操作数是布尔值，则将其转换为数值，然后在执行比较
			- 任何数于NaN进行关系比较，结果都是false
		- 相等操作符
			- 相等和不相等 ———— 先转换再比较 ( == / != ) 转换规则：
				- 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值 ———— false转换为0，true转换为1
				- 如果有一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值
				- 如果有一个操作数是对象，另一个操作数不是，则调用对象的valueof()方法，用得到的基本类型值按照前面的规则进行比较
				- null和undefined是相等的
				- 要比较相等性之前，不能将null和undefined转换为其他任何值
				- 如果有一个操作数是NaN,则相等操作符返回false，而不相等操作符返回true。
				- 即使两个值都是NaN，相等操作符也返回false，因为NaN不等于任何值，包括它本身
				- 如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符然会true，否则，返回false
			- 全等和不全等 ———— 仅比较不转换 ( === / !== )
		- 条件操作符
			- variable = boolean_expression ? true_value : false_value;
			- 相当以if(boolean_expression){
				   return true_value;
			  } else {
				   return false_value;
			  }
		- 赋值操作符
			- 由等号(=)表示，起作用就是把右侧的值赋给左侧的变量
			- += 相当于复合赋值 -= *= /= %= 等等
			- 设计这些主要目的是简化赋值，他们不会带来任何性能的提升
		- 逗号操作符
			- 在用于赋值时，逗号操作符总会返回表达式中的最后一项
			  var num = (1,2,3,4,5,6) //num = 6
	6、语句
		- ECMA-262规定了一组语句（流控制语句），语句通常由一个或多个关键字来完成给定任务
		- if语句
			- if (condition) statement else statement2
			- 其中的condition（条件）可以是任意的表达式，而且这个表达式求值的结果不一定是布尔值，ECMAScript会自动调用Boolean()转换这个表达式的结果为布尔值
			- 推荐使用代码块
		- do-while语句
			- 是一种后测试语句，即再对条件表达式求值之前，循环体至少会被执行一次
			- do {statement} while (expression)
		- while语句
			- 属于前测试循环语句，再循环体内的代码被执行之前，就会对出口条件求值，所以，循环体内的代码可能永远都不会被执行
			- while (expression) {statement}
		- for语句
			- 也是一种前测试循环语句，他具有在执行循环之前初始化变量和定义循环后要执行的代码的能力
			- for (initialization; expression; post-loop-expression) statement
			- for (var i = 0; i < 10; i ++) {console.log(123);}
			- 使用while循环做不到的，使用for循环同样也做不到
			- 再for循环的变量初始化表达式中，也可以不适用var关键字，该变量的初始化可以在外部执行
			- 由于ECMAScript中不存在块级作用域，所以再循环内部定义的变量在外部也可以访问
			- 将for的三个表达式：初始化表达式、控制表达式和循环后表达式全部省略，将会创建一个无限循环
			- 由于for语句存在极大的灵活性，所以他也是ECMAScript中最常用的一个语句
		- for-in语句
			- 一种精准的迭代语句，可以用看来枚举对象的属性
			- ECMAScript对象的属性没有顺序。因此通过for-in返回的属性名顺序是不可预测的
			- 如果表示要迭代的对象的变量值为null或undefined，那么将不会执行循环体
		- label语句
			- 使用label语句可以在代码中添加标签，以便将来使用
		- break和continue语句
			- break会立即退出循环，强制继续执行循环后面的语句
			- continue会立即退出循环，但退出循环后会从循环的顶部继续执行
			- 可以和label合用
		- with语句
			- 将代码的作用域设置到一个特定的对象中
			- with (expression) statement
			- with语句会导致性能下降，因此不建议使用
		- switch语句
			- switch (expression) {
				case value: statement
					break;
				case value: statement
					break;
				case value: statement
					break;
				default: statement
			}
			- 如果表达式等于（value），则执行后面的语句（statement）。而break关键字会导致代买执行流跳出switch语句。如果省略break，就会导致执行完当前case后们继续执行下一个case
			  最后的default关键字则用于在表达式不匹配前面任何一种情形的时候，执行机动代码（相当于宇哥else语句）
			- 可以省略break，但不要忘了加注释
			- 可以再switch语句中使用任何数据类型，每个case的值不一定是常量，可以是变量，甚至是表达式
			- switch语句在比较值时使用的是权等操作符，因此不会发生类型转换
	7、函数
		- 函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。
		- ECMAScript中的函数使用function关键字来声明，后跟一组参数以及函数体
		- 函数通过其函数名来调用，后面还要加上一对圆括号和参数（如果参数有多个，可以用逗号隔开）
		- 函数在定义时不必指定是否返回值，任何函数在任何时候都可以通过return语句后跟要返回的值来实现返回值，函数会在执行完return语句之后停止并立即退出，因此，再return后面的任何代码
		  都不会被执行
		- return语句也可以不带任何返回值，这种情况，函数在停止执行后将返回undefined
		- 严格模式的限制
			- 不能把函数命名为eval和arguments
			- 不能把参数命名为eval和arguments
			- 不能出现两个命名参数同名的情况
		- 理解参数
			- 函数不介意传递进来多少个参数，也不再回传进来参数是什么数据类型的
			- 函数的参数在内部是用一个数组来表示的，在函数内部可以通过arguments对象来访问这个参数数组
			- arguments对象并不是一个真正的数组（不是Array的实例），因为可以使用方括号语法访问他的每一个元素
			- 命名的参数只提供便利，但不是必须的
			- arguments对象可以与命名参数一起使用
			- arguments的值永远与对应命名参数的值保持同步
			- arguments的长度是由传入的参数数量决定的，而不是由命名参数的个数决定的
			- 没有传递值的命名参数将自动被赋予undefined值
			- 在声明一个函数时，函数内部hui开辟内存空间以存储命名参数的变量（指针），这一过程是在定义函数时完成的；而arguments时依据传入的实参而开辟内存空间用以存储实参副本，这一过程
			  是在调用函数时发生的。两者并没有在同一内存空间存储变量的值
			- 严格模式下
				- 在函数内部重写arguments的值会导致错误
				- 在函数内部定义arguments的值无效
			- ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数
		- 没有重载
			- 后命名的函数将替代先命名的函数（在两者的名称相同的情况下）

第四章 变量、作用域和内存问题
	- JavaScript变量松散类型的本质，决定了它只在特定时间用域保存特定值的一个名字而已
		- 松散类型变量的特点是变量定义时不需要指定变量的类型，变量在运行时可以随便改变数据的类型，但这种特性并不代表js变量没有类型，
		  当变量类型被确定后js的变量也是有类型的
	- 变量的值及其数据类型可以在脚本的生命周期内改变
	
	1、基本类型和引用类型的值
		- ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值
		- 基本类型值指的是简单的数据段，String、Number、Boolean、null和undefined。这五种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值
		- 引用类型值指那些可能由多个值构成的对象，是保存在内存中的对象。如Object、Array、Date、RegExp和Function。Js不能直接操作对象的内存空间。在操作对象时，实际上是在操作
		  对象的引用而不是实际的对象。引用类型的值是按引用访问的 <<=（不严密，当复制保存着对象的某个变量时操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象）
		- 动态的属性
			- 只能为引用类型的变量动态地定义属性和方法，也可以改变和删除其属性和方法
		- 复制变量值
			- 复制基本类型数据值时，var a = 1; var b = a; 这两个值可以参与任何操作而不会相互影响
			- 当复制引用类型时，复制的实际上是一个指针，而之歌指针指向存储在堆中的一个对象，复制操作结束后，两个变量实际上将引用同一个对象，
			  因此改变其中一个变量，就会影响另一个变量
			- 栈内存保存着基本数据类型以及引用类型的指针地址副本
			- 堆内存保存着引用类型所引用的对象
			- 栈会自动分配内存空间，会自动释放
			- 堆动态分配的内存，大小不定也不会自动释放
		- 传递参数
			- ECMAScript中所有的参数都是按值传递的，也就是说把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样
				- 基本类型值的传递如同基本类型变量的复制一样
				- 引用类型值的传递，如同引用类型变量的复制一样，传递的是这个对象放在栈内存中的内存地址
				- 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者叫形参，或者就是arguments对象中的一个元素）
				- 在向参数传递引用类型的值时，会把这个值在栈内存中的地址赋值给一个局部变量，因此这个局部变量的变化会反映在函数的外部
				- 可以把ECMAScript函数想象成局部变量
		- 检测类型
			- typeof操作符是确定一个变量时字符串、数值、布尔值还是undefined的最佳工具，如果变量的值是一个对象或null，则typeof操作符会返回object。说白了typeof操作符是检测基本数据
			  类型的得力助手
			- instanceof操作符可以知道被操作数是什么类型的对象，如果变量是给定引用类型的实例，那么就会返回true，也就是说instanceof是检测引用类型的最佳工具
			- 用instanceof操作符检测基本类型的值，返回值永远都是false，因为基本类型不是对象
	2、执行环境及作用域
		- 执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。我们编写的的代码
		  无法访问这个对象，但解析器会在处理数据时在后台使用它。
		- 全局执行环境是最外围的一个执行环境，在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的，某个执行环境中的所有代码执行
		  完毕后该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境知道应用程序退出————即关闭网页或浏览器时才会被销毁）
		- 函数执行环境：
			- 执行流依次进入的执行环境在逻辑上形成一个栈，栈的底部永远是全局环境，栈的顶部则是处于活动状态当前的执行环境（浏览器总是执行处于栈顶的上下文）。当执行流进入一个函数时
			  ，函数的环境就会被推入这个环境栈中，当函数执行完毕之后，栈将这个执行环境弹出，然后把控制全返回给之前的执行环境。这样实现的原因时由于Js的解释器是单线程的，也就是说同
			  一时刻只能执行发生一件事，其他等待执行的上下文或事件就会在这个环境栈中排队等候
		- 作用域链
			- 主要用途：进行变量查找，是保证对执行环境有权访问的所有变量和函数的有序访问
			- 作用域的前段时始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（实参）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个
			  对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境。而在下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量
			  对象始终都是作用域链中的最后一个对象
		- 标识符解析
			- 即沿着作用于来奶一级一级地搜索标识符的过程。始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到，会导致错误发生）
		- 在局部作用域中定义的变量可以在局部环境中与全局变量互换使用
		- 每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境
		- 延长作用域链
			- 执行环境的类型有两种：全局和局部（函数）
			- try-catch的catch块
			
			- with语句
		- 没有会计作用域
			- 任何时候变量只能通过var关键字声明
				- 省略var，只是为全局实现添加了一个属性（但它不是变量）
			- 变量不能使用delete删除
			- 在eval()上下文中可以删除var变量的值
			- 如果局部环境中存在同名的标识符，那么就不会使用位于父环境中的标识符
		- 变量查询是有代价的，访问局部变量比访问全局变量更快
	3、垃圾收集
		- 原理：找出那些不再继续使用的变量，然后释放其占用的内存
		- 标记清楚：
			- 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记
			- 他会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后在被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了
			- 垃圾收集器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间
		- 引用计数
			- 含义：跟踪记录每个值被引用的次数
		- 性能问题
			- IE的垃圾收集器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象（或数组）字面量和数组元素（slot）或者64kb的祖父因此高压包。达到上述任何一个临界值
			  垃圾收集器就会运行
			- IE7中各项临界值在初始时与IE6相等。如果垃圾收集例程回收的内存分配量低于15%，则变量、字面量和（或）数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界值
			  重置回默认值
			- IE中，调用window.CollectGarbage()方法可以立即执行垃圾收集 
			- Opera7以及更高版本中，调用window.opera,collect()也会启动垃圾收集例程
		- 管理内存
			- 优化内存占用的最佳方法，就是为执行中的代码只保存必要的数据，一旦数据不再有用，最好通过将其值设置为null来释放其引用 ———— 接触引用
			- 解除一个值的引用并不意味着自动回收该值所占用的内存，真正的作用时让值脱离执行环境，以便垃圾收集器下次运行时将其回收。
			
第五章 引用类型
	- 引用类型是一种数据结构，用于将数据和功能组织在一起。它通常被称为类，虽然ECMAScript从技术上讲是一门面向对象的语言，但不具备传统的面向对象语言所支持的类和接口等基本结构。
	  （引用类型不是类，不能混淆）
	- 对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的，构造函数本事就是一个函数，只不过是出于创建新对象的目的而定义的。
	1、Object类型
		- 大多数引用类型值都是Object类型的实例
		- 创建方法：
			- 使用new操作符后跟Object构造函数
			- 使用对象字面量表示法。对象字面量是对象定义的一种简写形式，也是向函数传递大量可选参数的首选方式（使用对象字面量定义对象时，不会调用Object构造函数）
		- 访问对象属性的方法：
			- 点表示法object.name
			- 方括号表示法object[name] => 可以通过变量来访问属性
			- 除非必须使用变量访问属性，否则我们建议使用点表示法
	2、Array类型
		- Array是ECMAScript中除Object之外最常用的类型
		- ECMAScript中的数组可以保存任何类型的数据
		- 创建数组：
			- 使用Array构造函数
				- 如果预先知道数组要保存的项目数据，也可以给构造函数传递该数量，而该数量也会自动变成length
				=> new Array('red', 'orange') // red, orange, 2, new Array(3) // length = 3
			- 使用数组字面量表示法
			- 方括号的索引表示要访问的值 
			  => name[0] // 1 => var name = [1,2,3,4]
			- 数组的项数保存在其length属性中，他不是只读的，可以通过这个属性，从数组的末尾移出项或添加项（数组最后一项的索引始终是length - 1, 所以下一个新项的位置就是length）
		- 检测数组：
			- 使用instanceof操作符
			- Array.isArray()方法一样，作为参数的属性名必须以字符串形式指定
		- 转换方法：
			- 所有对象都具有toLocaleString()、toString()、valueOf()方法
				- 调用valuOf()返回的数组本身
				- 调用toString()方法返回数组中每个值的字符串形式拼接成的一个以逗号分隔的字符串
				- 调用toLocaleString()方法返回的值和上述两种大体一样
			- 使用join()方法，可以使用不同的分隔符来构建这个字符串
				- 接受一个参数，即作为分隔符的字符串，然后返回包含所有数组项的字符串
		- 栈方法：
			- 栈是一种LIFO(Last-In-First-Out，后进先出)的数据结构，即最新添加的项最早被移除。而栈中项的插入和移除只发生在一个位置————栈的顶部
			- ECMAScript为数组提供的栈方法有push()和pop()
				- push()方法可以接受任意数量的参数，把他们逐个添加到数组的末尾，并返回修改后的数组长度
				- pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回被移除的项
		- 队列方法：
			- 队列数据结构的访问规则是FIFO(First-In-First-Out，先进先出)。即队列在列表的末端添加项，从列表的前端移除项
			- 实现这一操作的数组方法就是shift()：
				- shift()能够移除数组中的第一个项并返回该项，同时将数组长度减一
				- shift()和push()可以模拟队列方法
			- ECMAScript提供了一个unshift()方法。
				- 与shift()的用途相反，他能在数组前端添加任意个项并返回新数组的长度
				- 使用unshift()和pop()方法可以反方向模拟队列，即在数组的前面添加项，在数组的后面移除项
				- IE7及更早版本对unshift()有错误，即总是返回undefined而不是数组的新长度
		- 重排序方法：
			- 数组中存在两个可以直接用来重排序的方法：reverse()和sort()
				- reverse()方法会反转数组项的顺序
				- sort()方法在默认情况下按升序排列数组项，sort()会调用每个数组的toString()方法，然后比较得到的字符串，即使数组中的每一项都是数值，sort()方法比较的也是字符串
					- 可以接受一个比较函数作为参数，比较函数接受两个参数
					=> function compare(v1, v2) {
							if(v1 < v2) {
								return -1;
							} else if(v1 > v2) {
								return 1;
							} else {
								return 0;
							}
					}		(升序排序) => (反之则降序)
					
					=> function compare(v1, v2) {
						return v1 - v2;
					}		(只能比较数值)
					
				- 他们两个的返回值都是经过排序之后的数组
		- 操作方法：
			- concat()方法基于当前数组中的所有项创建一个新数组
				- 先创建一个数组副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组
			- slice()方法基于当前数组中的一会多个项创建一个新数组
				- 接受一或两个参数，即要返回项的起始和结束位置，在只有一个参数的情况下，slice()方法返回从该起始为指导数组末尾的所有项（可以用来将将伪数组转换成数组 => Array.prototype.slice.call(fakeArray)）
				- 在接受两个参数的情况下，返回的数组包括起始位置到结束位置之间指定的所有项，但不包括结束位置的项
				- 如果slice()的参数中有一个负数，则用数组长度加上该数来确定相应的位置
				- 如果结束位置小于起始位置，则返回空数组
			- splice()方法主要是项数组的中部插入项：
				- 删除：可以删除任意数量的项，指定两个参数：起始参数和要删除项的数量
				- 插入：可以向指定位置插入任意数量的项，指定三个参数：起始位置、要删除项的个数和要插入的项
				- 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，指定三个参数：起始位置、要删除项的个数和要插入的项
				- splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）
		- 位置方法：
			- ECMAScript5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接受两个参数：要查找的项和（可选）表示查找起点位置的索引，然后查找项所在位置的索引
			- indexOf()从前往后找，lastIndexOf()从后往前找
			- 这两个方法在没找到的情况下返回-1
			- 比较的时候使用的是全等操作符
		- 迭代方法：
			- ECMAScript5为数组定义了5个迭代方法。每个方法都接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用于对象————影响this的值
			- 传入这些方法中的函数会接受三个参数：数组项的值(item)、该项在数组中的位置(index)和数组对象本身(Array)
			- 五个方法：
				- every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true
				- filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组
				- forEach()：对数组中的每一项运行给定函数，这个方法没有返回值
				- map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组
				- some()：对数组中的每一项运行给定函数，如果函数对任一项返回true，则返回true
			- 以上方法都不会修改原数组中包含的值
			- 其中every()和some()都用于查询数组中的项是否满足某个条件
		- 归并方法：
			- 两个归并方法：reduce()和reduceRight()
			- 这两个方法会迭代数组的所有项，然后构建一个最终返回的值
			- reduce从第一项开始遍历到最后，而reduceRight则从最后一项便利到第一项
			- 接受两个参数：一个在每一项上调用的函数和（可选）作为归并基础的初始值
			- 传入的函数接受四个值：前一个值，当前值，项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数始数组的第二项
	3、Date类型
		- ECMAscirpt中的Date类型是在早期的Java中的java.util.Date类基础上构建的
		- Date类型使用自UTC（1970年1月1日零时）开始经过的毫秒数来保存日期。Date类型保存的日期能够精确到1970年1月1日之前或之后的100 000 000年
		- 如果想根据特定的时间和日期来创建对象，必须传入相应的毫秒值，但ECMAScript5未来简化这一操作，提供了两个方法：Date.parse()和Date.UTC()
			- Date.parse()接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数
				- 如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN
				- 如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()，即：
				=> var a = new Date("May 25, 2004")，这行代码会得到与前面相同的日期对象
			- Date.UTC()同样也会返回表示日期的毫秒数，但他与Date.parse()在构建值时使用不同的信息
				- Date.UTC的参数是年份、基于0的月份、月中的哪一天(1-31)、小时数(0-23)、分钟(0-59)、秒以及毫秒。只有年和月是必须的，如果没有月中的天数，则为1，如果没有其它的，则统统为0
		- Date.now表示调用这个方法时的日期华人事件的毫秒数
			- 可以用作计时器
			- 在不支持Date.now()的浏览器中，使用+new Date()也可以获得同样的效果
		- 继承的方法：
			- Date类型同样也有toLocaleString()、toString()和valueOf()方法
				- Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间
				- toString()则通常返回带有时区信息的日期和时间，其中一般以军用时间表示
				- 至于valueOf()则返回日期的毫秒数
		- 日期格式化方式：
			- toDateString()————以特定于实现的格式显示星期几、月、日和年
			- toTimeString()————以特定于实现的格式显示时、分、秒和时区
			- toLocaleDateString()————以特定于实现的格式显示时、分、秒和时区
			- toLocaleTimeString()————以特定与实现的格式显示星期几、月、日和年
			- toUTCString()————以特定于实现的格式显示完整的UTC日期
			- toGMTString()————与toUTCString()等价的方法，其存在的目的在于向后兼容
		- 日期/时间组件方法
			- getTime()————返回表示日期的毫秒数；与valueOf()返回的值相同
			- setTime()————以毫秒数设置日期，会改变整个日期
			- getFullYear()————取得四位数的年份
			- getUTCFullYear()————返回UTC日期的四位数年份
			- setUTCFullYear()————设置日期的年份。传入的年份值必须是四位数
			- setFullYear()————设置UTC日期的年份。传入的年份值必须是四位数
			- getMonth()————返回日期中的月份(0-11)
			- getUTCMonth()————UTC
			- setMonth()————设置日期的月份，必须大于0，超过11则增加年份
			- setUTCMonth()————UTC
			- Date————天数
			- Day————星期几
			- Hours————小时
			- Minutes————分钟
			- Seconds————秒钟
			- Milliseconds————毫秒数
			- getTimezoneOffset()————返回本地时间与UTC时间相差的分钟数
	4、RegExp类型
		- ECMAScript通过RegExp类型来支持正则表达式
		- 语法： var expression = /pattern/flags => /模式/标志
		- 模式部分可以是任何简单的或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则都可以带有一个或多个标志（flags），用以标明正则表达式的行为
		- 3个标志（flags）：
			- g：表示全局模式，即模式将被应用于所有字符串
			- i：表示不区分大小写
			- m：表示多行模式，即在到达一行文本末尾时还会继续查找下行中是否存在与模式匹配的项
			- 一个正则表达式就是一个模式与上述三个标志的组合体
		- 字符类：
			\d			0-9的任何数字
			\D			任何非数字字符
			\w			任何单词字符，即A-z、0-9以及下划线(_)字符
			\W			任何非单词字符
			\s			任何空白字符
			\S			任何非空白字符
			.			除换行符(\n)之外的任意单个字符
			[...]		匹配位于方括号内的任意一个字符
			[^...]		匹配除方括号以内的任意一个字符
		- 量词：
			{n}			前一项出现n次
			{n,}		前一项出现n次，或n次以上
			{n,m}		前一项至少出现n次，最多出现m次
			?			前一项出现0次或1次
			+			前一项出现1次或多次
			*			前一项出现0次或多次
		- 位置字符：
			^			模式必须位于字符串的开头，如果是多行字符串，模式就位于一行的开头，对于多行文本，需定义m
			&			模式必须位于字符串的结束位置，如果是多行字符串，模式就位于一行的结束位置，对于多行文本，需定于m
			\b			匹配单词分界位置，即单词字符与非单词字符之间的位置
			\B			匹配非单词分界位置
		- 纵向：/a{2,3}b/gi
		- 横向：/a[bc]d/gi
		- 贪婪：/a{2,3}b/gi => 正则会尽可能多的匹配正确项
		- 惰性：/a{2,3}?b/gi => 任何量词加上？都会匹配最少项
		- 多选分支：(P1|P2|P3)P1、P2、P3是子模式，用|分开，表示其中任何之一，分支也是惰性的，即当前面的匹配上了，后面的就不尝试了
		- 非捕获分组：
			- (?=P) 即P之前的位置匹配
			- (?!P) 即除P之前的位置都匹配
			- (?:P) S(?:B|C) => SB || SC
		- 正则表达式的构建:
			- 平衡法则
				- 匹配预期的字符串
				- 不匹配非预期的字符串
				- 可读性和可维护性
				- 效率
			- 构建正则的前提
				- 是否能使用正则
				- 是否有必要使用正则
				- 是否有必要构建一个复杂的正则
			- 准确性
				- 能匹配预期的目标，并且不匹配非预期的目标
			- 效率
				- 减少回溯
		- 正则的四种操作：
			- 验证
			- 切分
			- 提取
			- 替换
		- 正则的实例属性：
			- global：布尔值，表示是否设置了g标志
			- ignoreCaes：布尔值，表示是否设置了i标志
			- lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起
			- multiline：布尔值，表示是否设置了m标志
			- source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回
		- 正则的方法：
			- exec()：主要用于捕获组，接受一个参数=>要应用模式的字符串，返回包含第一个匹配项信息的数组，或者在没有匹配的情况下返回null
				- index：表示匹配项在字符串的位置
				- input：表示应用在正则表达式的字符串
					- 在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串
			- test()：接受一个字符串参数，在模式于该参数匹配的情况下返回true，否则返回false
			- 正则的两个方法，当有g时，每一次匹配完成后，都会修改lastIndex（多次调用的情况下）
		- 正则的属性分别有一个上属性名和一个短属性名：
			- input			$_			最近一次要匹配的字符串
			- lasiMacth		$&			最近一次的匹配项
			- lastParen		$+			最近一次匹配的捕获项
			- leftContext	$`			input字符串中lastMatch之前的文本
			- multiline		$*			布尔值，表示是否所有表达式都是用多行模式
			- rightContext	$'			input字符串中lastMacth之后的文本
			- $1\$2\$3					使用括号的子字符串匹配
	5、Function类型
		- 函数是对象，函数名是指针
		- 使用不带圆括号的函数名是访问函数指针，而不是调用函数
		- 函数内部属性
			- arguments：是一个类数组对象，主要用途是保存函数参数，只能在函数内部访问
				- callee：是一个指针，指向拥有这个arguments对象的函数
			- this：this引用的是函数执行的环境对象————或者也可以说是this值（挡在网页的全局作用域中调用函数时，this对象引用的就是window）
			- caller：保存了调用当前函数的函数的引用，如果是在全局作用于中调用当前函数，他的值为null
			- 当函数在严格模式运行时，访问arguments.callee会导致错误，ECMAScript5还定义了arguments.caller属性，但在严格模式下访问它也会导致错误，而在非严格模式下，这个属性始终时undefined
			- 严格模式下，不能为函数的caller属性赋值
		- 函数的属性和方法
			- length：表示函数希望接受的命名参数的个数，即形参数量
			- prototype：对于ECMAScript中的引用类型而言，prototype是保存他们所有实例方法的真正所在，即prototype是函数的原型对象
			- apply()和call()
				- 都接受两个参数：①在其中运行函数的作用域，②参数数组（可以是array的实例，也可以是arguments对象）
				- call()接受的是参数列表，apply()接受的是参数数组
				- 他们可以扩充函数赖以运行的作用域
			- bind()：会创建一个函数的实例，其this值会被绑定到传给bind()函数的值
			- bind() call() apply()比较：
				- 三者都是用来改变函数的this对象的指向的
				- 三者第一个参数都是this要指向的对象，也就是想指定的上下文
				- 三者都可以利用后续参数传参
				- bind是返回对应的函数，便于稍后调用，apply和call则是立即调用
	6、基本包装类型
		- 三个特殊的引用类型：Boolean、Number、String
		- 基本类型值不是对象
		- 每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据
			- 创建一个String、Number、Boolean类型的实例
			- 在实例上调用指定的方法
			- 销毁这个实例
		- 引用类型和基本包装类型的区别：
			- 使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中
			- 自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁
		- 对基本包装类型的实例调用typeof会返回"object"，在转换为布尔类型时值都是true
		- 对基本包装类型字面量使用instanceOf进行类型检测，都会返回false
		- 把字符串传给Object构造函数，就会创建String的实例，传入数值就会得到Number的实例，传入布尔值就会得到Boolean的实例
		- Boolean类型：
			- valueOf() =》 true $$ false
		- Number类型：
			- toFixed()：会按照指定的小数位返回数值的字符串表示，接受一个参数：指定的小数位
				- 如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入
			- toExponential()：返回以指数表示法(e表示法)表示的数值的字符串形式，接受一个参数：指定的小数位
			- toPrecision()：可能返回固定大小格式，也可能返回指数格式，具体规则看哪种格式最合适，接受一个参数：表示数值的所有数字的位数(不包括指数部分)
			- 以上三种方法都可以通过向上或向下舍入(即四舍五入)，做到以最准确的形式来表示带有正确小数位的值
		- String类型：
			- 每个String类型都有一个length属性，返回字符串的长度
			- 字符方法：
				- charAt()和charCodeAt()用于访问字符串中特定的字符
					- 都接受一个参数，即基于0的字符位置
					- charAt()以单字符字符串的形式返回给定位置的那个字符
					- charCodeAt()则返回字符编码
				- 可以使用方括号加数字索引值来访问字符串中的特定字符
			- 字符串操作方法：
				- concat()：用于将一或多个字符串拼接起来，返回拼接得到的新字符串，接受任意参数，即可以拼接任意多个字符串
					- 一般用+操作符代替concat拼接字符串
				- 基于子字符串创建新字符串的方法：slice()、substr()、substring()
					- 返回被操作字符串的一个子字符串
					- 接受一或两个参数：
						- 指定字符串的开始位置
						- 到哪里结束
						- slice()和substring()的第二个参数是子字符串最后一个字符串的后面位置
						- substr()的第二个是返回的字符串个数
						- 如果没有第二个参数，就以字符串末尾作为结束位置
					- 他们不会修改字符串本身的值
					- 参数是负数的情况下：
						- slice()会将负数于字符串的长度相加
						- substr()会将负的第一个参数加上字符串的长度，将负的第二个参数转换为0
						- substring()会将所有负值参数都转换为0，它会将较小的数作为开始位置，将较大的数作为结束位置
			- 字符串位置方法：
				- indexOf()和lastIndexOf()
					- 接受两个参数
						- 子字符串
						- 从那哪个位置开始搜索
					- 如果有，则返回子字符串出现的位置索引；如果没有，则返回-1
				- 可以使用循环来匹配所有的子字符串
			- trim()方法：
				- 创建一个字符串的副本，删除前置和后缀的所有空格，然后返回结果
				- trimLeft()和trimeRight()
			- 字符串大小写转换方法：
				- toLowerCase/toLocaleLowerCase()和toUpperCase/toLocaleUpperCase()
			- 字符串的模式匹配方法：
				- macth()
					- 接受一个正则表达式，然会一个匹配的数组
				- search()
					- 接受一个字符串或者一个正则表达式，然会字符串中第一个匹配项的索引，如果没有找到，则返回-1
				- replace()
					- 接受两个参数：
						- 一个正则表达式或者字符串（这个字符串不会被转为正则表达式）
						- 可以是一个字符串，也可以是一个函数
							- 这个函数接受三个参数
								- 模式的匹配项
								- 模式匹配想在字符串中的位置
								- 原始字符串
					- 返回替换后的字符串
				- split()
					- 基于指定的分隔符将一个字符串分割成多个字符串，并将其放在一个数组中
					- 接受两个参数：
						- 指定的分隔符可以是一个字符串，也可以是一个正则表达式
						- 指定参数的大小，以便确保返回的数组不会超过既定大小
			- localeCompare()：
				- 比较两个字符串，并返回下列值中的一种
					- 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数
					- 如果相等，返回0；
					- 如果字符串在字母表中排在字符串参数之后，返回1
			- formCharCode():
				- 接受一个或多个字符编码，然后转换成一个字符串
	7、单体内置对象
		- Global和Math
		- Global：
			- 全局对象
			- 不属于其他对象的属性和方法，最终都是他的属性和方法
			- encodeURI():
				- 对URI进行编码
				- 除空格之外的其他字符原封不动，只有空格被替换
			- encodedeURIComponent():
				- 对URI进行编码
				- 使用对应的编码替换所有非字母数字字符
			- decodeURI()和decodeURIComponent()：
				- 对字符串进行解码
			- eval():
				- 类似于一个解析器，他直接收一个参数，即要执行的ECMAScript(JavaScript)字符串
					- 当解析器发现代码中调用eval()方法时，会将传入的参数当作实际的语句来解析，然后把执行结果插入到原位置
					- eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链
					- 在严格模式下，外部无法访问eval()中创建的变量或函数
			- 在Web浏览器中，Global指的时window对象
			- 取得Global对象的方法：
				var global = function() {
					return this;
				}();
		- Math对象：
			- min()和max():
				- 用于确定一组数值中的最小值和最大值
				- Math.max.apply(Math, Array)
			- Math.ceil()：向上舍入
			- Math.floor(): 向下舍入
			- Math.round(): 四舍五入
			- random()：
				- 返回大于0小于1的一个随机数
				- 值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)
				- 可以用函数来计算可能值的总数和第一个可能值：
					function selecFrom(lowerV,upperV) {
						var choice = upperV - lowerV + 1；
						return Math.floor(Math.random() * choice + lowerV)
					} 












		
		
		
